.program cdhc_in_register


.wrap_target
init:
  set pins, 0x07

ready_reg:
  push NoBlock
	set X,    0x07

latching:
  set pins, 0x06
  set pins, 0x03

read_reg:
  set pins, 0x01
	in pins,  1
  set pins, 0x05
	jmp x-- read_reg

  mov ISR, :: ISR
;  in null, 23
	jmp ready_reg

.wrap
	
 
% c-sdk {
#include <stdlib.h>
#include "hardware/dma.h"
#include "hardware/pio.h"
#include "hardware/gpio.h"
#include "resource/controller_configurations.h"

extern demas reg_in;

//  Don't forget to add your | repeating_timer_t my_timer |;

#define separate_r1(d) (uint8_t)( (d & 0x0003))
#define separate_r2(d) (uint8_t)( ((d & 0x000C) >> 2) & 0x0003)
#define separate_r3(d) (uint8_t)( ((d & 0x0030) >> 4) & 0x0003)
//  Separate IO is just taking in buttons.
#define separate_IO_b1(d) (bool)( ((d & 0x00C0) >> 6) & 0x0001)
#define separate_IO_b2(d) (bool)( ((d & 0x00C0) >> 6) & 0x0002)


//  Setup a DMA with read & write increment disabled, at 32bits, full speed.
void setup_dma(demas *cfig, pio_rot *set, cdhc_pio *cdhc){

  cfig->channel = dma_claim_unused_channel(true);
    printf("\nOur DMA Channel: %i.\n", cfig->channel);
  dma_channel_config c = dma_channel_get_default_config(cfig->channel);
  channel_config_set_read_increment(&c, cfig->r_inc);
  channel_config_set_write_increment(&c, cfig->w_inc);

  channel_config_set_dreq(&c, pio_get_dreq(cdhc->port, cdhc->sm, false));

  printf("\nWrite to address: 0x%08x.\n", &set->frr);
   printf("Read from address: 0x%08x.\n\n", &pio0->rxf[0]);

  dma_channel_configure(cfig->channel, &c, &set->frr, &pio0->rxf[cdhc->sm], 1, false);

}

static inline void register_in_init(pio_cdhc *cfig){

uint32_t p_mask = ((1 << cfig->Pins.data) | (1 << cfig->Pins.lat) | (1 << cfig->Pins.inh) | (1 << cfig->Pins.clk));
uint32_t pdir_mask = ((0 << cfig->Pins.data) | (1 << cfig->Pins.lat) | (1 << cfig->Pins.inh) | (1 << cfig->Pins.clk));
pio_sm_set_pins_with_mask(cfig->Pio.port, cfig->Pio.sm, 0, p_mask);
pio_sm_set_pindirs_with_mask(cfig->Pio.port, cfig->Pio.sm, pdir_mask, p_mask);
pio_sm_config c = pio_get_default_sm_config();
pio_gpio_init(cfig->Pio.port, cfig->Pins.data);  			// ex pin 3
  gpio_pull_up(cfig->Pins.data);
pio_gpio_init(cfig->Pio.port, cfig->Pins.lat);  	// ex pin 4
pio_gpio_init(cfig->Pio.port, cfig->Pins.inh);  	// ex pin 5
pio_gpio_init(cfig->Pio.port, cfig->Pins.clk);			// ex pin 6
sm_config_set_in_pins(&c, cfig->Pins.data);
sm_config_set_set_pins(&c, cfig->Pins.lat, 3);
sm_config_set_in_shift(&c, true, false, 1);
sm_config_set_fifo_join(&c, PIO_FIFO_JOIN_NONE);
sm_config_set_clkdiv(&c, 125);
pio_sm_init(cfig->Pio.port, cfig->Pio.sm, cfig->Pio.offset, &c);

}


//  Returns can_add value.  Checks if program can be added, then if true, adds program.
bool add_cdhc_program(pio_cdhc *cfig){
      cfig->Pio.can_add = false;
      cfig->Pio.can_add = pio_can_add_program(cfig->Pio.port, &cdhc_in_register_program);
          printf("\nCommand Program: %c.\n", (cfig->Pio.can_add ? 'Y' : 'N'));
      if(cfig->Pio.can_add){
          cfig->Pio.offset = pio_add_program(cfig->Pio.port, &cdhc_in_register_program);
      }
      return (cfig->Pio.can_add);
  }


//  Initialize CDHC pio program.
//  DMA enabled.
void init_cdhc_program(pio_cdhc *cfig, demas *mas, pio_rot *set){

    if(add_cdhc_program(cfig)){
      register_in_init(cfig);
      pio_sm_set_enabled(cfig->Pio.port, cfig->Pio.sm, true);
    }
    setup_dma(mas, set, &cfig->Pio);
}


int16_t rotary_logic(uint8_t A, uint8_t B){

      if( (B == 0x03)){

        if( (A == 0x02)){
        //   printf("Increment.\n");
            return 1;
          }else if( (A == 0x01)){
            return -1;
          }
    }
      return 0;
}


void calc_rotary_values(pio_rot *set){

  int8_t a, b, c = 0;
  int8_t l, y, z = 0;
    
  set->r1_b = separate_IO_b1(set->frr);
  set->r2_b = separate_IO_b2(set->frr);
  
  if(set->frr == 0x11 || set->frr == 0x33){
    a = 0;
  }else{
    a = separate_r1(set->frr);
  }

  if(set->frr == 0x24){
    b = 0;
  }else{
    b = separate_r2(set->frr); 
  }

  c = separate_r3(set->frr);


  if(a != set->pr1){
    l = rotary_logic(a, set->pr1);
      if(l != 0){
    set->r1 += (l == 1) ? set->rot_a_inc : -(set->rot_a_inc);
      }
  }
  
  if( b != set->pr2){
    y = rotary_logic(b, set->pr2);
      if(y != 0){
    set->r2 += (y == 1) ? set->rot_b_inc : -(set->rot_b_inc);
      }
  }
  
  if(c != set->pr3){
    z = rotary_logic(c, set->pr3);
      if(z != 0){
    set->r3 += (z == 1) ? set->rot_c_inc : -(set->rot_c_inc);
      }
  }
    set->pr1 = a;
    set->pr2 = b;
    set->pr3 = c;

}


bool rotation_values(repeating_timer_t *rt){
    //  printf("RAW value of rxf pio fifo register 1: 0x%04x\n", pio0->rxf[0]);
  calc_rotary_values(&rotary_data);

  return true;
}


bool dma_fire(repeating_timer_t *rt){
  if(dma_channel_is_busy(reg_in.channel)){
    printf("DMA Busy\n");
  // printf("Write to address: 0x%08x.\n", &rotary_data.frr);
  }else{
    dma_channel_set_read_addr(reg_in.channel, &pio0->rxf[0], false);
    dma_channel_set_write_addr(reg_in.channel, &rotary_data.frr, false);
    dma_channel_set_trans_count(reg_in.channel, 1, true);

    dma_channel_start(reg_in.channel);
  }
}

/*

bool fifo_pulled(pio_cdhc *cfig, pio_rot *data){

  if(pio_sm_get_rx_fifo_level(cfig->Pio.port, cfig->Pio.sm) > 0){
    data->fr = pio_sm_get_blocking(cfig->Pio.port, cfig->Pio.sm);
  }else{
    input->fifo_return = 0;
  }
    crementatin(input);
  //  print_rotary(input);

  return true;
  
}


*/

%}
